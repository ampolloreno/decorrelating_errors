%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% RevTeX 4.1 LaTeX
% Kevin C. Young
% Scalable & Secure Systems Research (08961)
% Thu Mar  5 15:29:19 PST 2015
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[aps,nofootinbib,pra,notitlepage,twocolumn]{revtex4-1}
\usepackage{amsfonts,amsmath,amssymb,amsthm}
 \usepackage{array,bm,color}
\usepackage{epsfig,graphicx,nomencl,revsymb4-1,upgreek,url}
\usepackage{hyperref}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{graphicx}
\usepackage{calc}
\usepackage{siunitx}
\usepackage{tabularx}
\newcolumntype{Y}{>{\centering\arraybackslash}X}
\graphicspath{{./figures/}}
\hypersetup{colorlinks=true, pdfauthor=Anthony M. Polloreno, pdftitle=Robustly decorrelating errors with mixed quantum gates, citecolor=blue, linkcolor=blue}
\newcommand{\tr}{{\rm Tr\thinspace}}
\newcommand{\bra}[1]{\ensuremath{\left\langle{#1}\right\vert}}
\newcommand{\ket}[1]{\ensuremath{\left\vert{#1}\right\rangle}}
\newcommand{\braket}[2]{\left\langle #1 | #2 \right\rangle}
\newcommand{\ketbra}[2]{\left| #1 \right\rangle\!\!\!\,\left\langle #2 \right|}
\newcommand{\abs}[1]{\left\vert #1 \right\vert}
\newcommand{\expect}[1]{\ensuremath{\left\langle{#1}\right\rangle}}
\newcommand{\timeorder}{\ensuremath{\underset{\leftarrow}{\mathcal{T}}}}
% \newcommand{\identmat}{{\mathbb1}}
\newcommand{\order}[1]{\mathcal{O}\left( #1 \right)}
\newcommand{\diag}[1]{\mathrm{diag}\{#1\}}
\newcommand{\trans}[1]{#1^\mathsf{T}}
\newcommand{\T}{\mathsf{T}}
\newcommand{\erf}[1]{Eq.~(\ref{#1})}
\newcommand{\needcite}{{\color{blue}\textsuperscript{[citation needed]}}}
% \newcommand{\note}[1]{{\color{red}[#1]}}
\newcommand{\note}[1]{}
\newcommand{\kcy}[1]{{\color{red}[#1]\textsubscript{\rm{KCY}}}}
\newcommand{\amp}[1]{{\color{red}[#1]\textsubscript{\rm{AMP}}}}
\newcommand{\deriv}[0]{{\frac{d}{d\vec{\delta}}}}

\newcommand{\actual}{\ensuremath{\tilde{\mathsf{G}}}}
\newcommand{\actmat}{\ensuremath{\tilde{\mathcal{G}}}}
\newcommand{\target}{\ensuremath{{\mathsf{G}}}}
\newcommand{\tarmat}{\ensuremath{{\mathcal{G}}}}
\newcommand{\error}{\ensuremath{{\mathsf{E}}}}
\newcommand{\errmat}{\ensuremath{{\mathcal{E}}}}
\newcommand{\genmat}{\ensuremath{{\mathcal{L}}}}
\newcommand{\vectorize}[1]{\ensuremath{\mathsf{vec}\left(#1\right)}}
\newcommand{\AGI}{\ensuremath{\epsilon_\mathcal{F}}}
\newcommand{\dnorm}{\ensuremath{\epsilon_\diamond}}
\newcommand{\identmat}{\ensuremath{\mathcal{I}}}
\newcommand{\ident}{\ensuremath{\mathsf{I}}}
\newcommand{\0}{\ensuremath{\mathbf{0}}}
\newcommand{\weight}{\ensuremath{w}}

\newcommand{\bunderbrace}[2]{
  \begin{array}[t]{@{}c@{}}
  	#1\\
  	\parbox{\widthof{#1}}{$\scriptscriptstyle#2$}
  \end{array}}

%-------------Header begins here----------------------------------------
\begin{document}
\title{Robustly decorrelating errors with mixed quantum gates}

\author{Anthony M. Polloreno}
\email[Email: ]{ampolloreno@gmail.com}
\affiliation{Rigetti Computing, Berkeley, CA}

\author{Kevin C. Young}
\affiliation{Quantum Performance Laboratory, Sandia National Laboratories, Livermore, CA}

\date{\today}

\begin{abstract}
\noindent Coherent errors in quantum operations are ubiquitous. Whether arising from spurious environmental couplings or errors in control fields, such errors can accumulate rapidly and degrade the performance of a quantum circuit significantly more than an average gate fidelity may indicate. As Hastings \cite{Hastings2017} and Campbell \cite{Campbell2017} have recently shown, by replacing the deterministic implementation of a quantum gate with a randomized ensemble of implementations, on can dramatically suppress coherent errors. Our work begins by reformulating the results of Hastings and Campbell as a quantum optimal control problem. We then discuss a family of convex programs designed to improve the performance, implementability, and robustness of the resulting mixed quantum gates. Finally, we implement these mixed quantum gates on a superconducting qubit and discuss randomized benchmarking results consistent with a marked reduction in the coherent error.\\
{[1]} M. B. Hastings, \emph{Quantum Information \& Computation} 17, 488 (2017). \\
{[2]} E. Campbell, \emph{Physical Review A} 95, 042306 (2017).
\end{abstract}

\pacs{}

\maketitle


% ==============================================================================
% Section: Introduction
% ==============================================================================
\section{Introduction}
\label{sec:introduction}
\noindent The ultimate impact of a gate error on the performance of a quantum circuit depends strongly on both the magnitude and the nature of the error. Systematic, or \emph{coherent}, errors can arise from poorly calibrated controls or approximate gate compilations that induce repeatable, undesired unitary errors on the state of a quantum information processor (QIP). Errors of this type are correlated in time and may add up constructively or destructively, depending on details of the circuit in which they appear. This can make it difficult to construct tight analytic bounds on circuit performance \cite{Beale2018}, and numerical studies are often limited by the high computational cost of modeling coherent errors. Contrast this against random, or \emph{stochastic}, errors which often result from high-frequency noise in the controls or the environment. Systems with stochastic errors can usually be accurately modeled by defining a rate of various discrete errors in the system, such as a bit flips or phase flips. These errors are significantly easier to simulate on a classical computer, and their impact on quantum circuits is much easier to estimate \cite{Beale2018}.

\begin{figure}[t]
  \centering
  \includegraphics[width=\columnwidth]{simple_example.pdf}
  \caption{\textbf{Simple example of a mixed quantum gate:} Using optimal control, two implementations of a $Z_\pi$ gate are designed to have equal and opposite coherent errors (if one implementation over-rotates by a small angle $\theta$, then the other \emph{under}-rotates by $\theta$). Each time the gate is used, one of these two implementations is chosen at random. The resulting effective quantum gate is equivalent to a perfect implementation of the gate followed by dephasing with associated probability $\order{\theta^2}$.}
  \label{fig:simple_example}
\end{figure}

Campbell \cite{Campbell2017,1811.08017} and Hastings \cite{Hastings2017} have developed a technique for suppressing coherent noise by replacing deterministic gate implementations with a \emph{mixed quantum gate} (MQG) consisting of a randomly sampled ensemble of implementations. They focus on errors in gate compilation, such as those that arise from the Solovey-Kitaev algorithm, for which any lingering approximation errors are generally coherent, even if the underlying native gates are perfect. Different approximate gate compilations of the same target unitary will almost certainly result in different unitary errors. So by selecting from these various compilations at random, the resulting quantum channel becomes a mixture of unitaries \cite{DBLP:journals/corr/cs-CC-0012017}, which can have significantly less coherent error than any single compilation on its own. A very simple example of this reduction in coherent error by mixed quantum gates is illustrated in Fig.~\ref{fig:simple_example}. 

In this article, we extend the work of Campbell and Hastings to numerically optimized quantum gates and show that the advantages of their approach can be made robust to drift and model uncertainty. We provide an explicit series of convex programs able to efficiently compute MQGs with a variety of useful properties. We demonstrate our results on a superconducting testbed device at Rigetti Computing.  In a simple experiment based on randomized benchmarking circuits, MQGs demonstrate a marked improvement in error rates and a reduced variance in circuit outcome probabilities, consistent with a significant reduction in the coherence of the error \cite{Ball2016}. We further apply our methods in simulation, constructing both single- and two-qubit mixed unitary controls that are robust to drift and uncertainty in the control parameters.


% ==============================================================================
% Section: Mathematical preliminaries
% ==============================================================================
\section{Preliminaries}
\label{sec:preliminaries}

\subsection{Representing Errors in Quantum Gates}
\label{sec:rep_errors}
\noindent In order to implement a desired unitary gate, $\target$, on a quantum device, one generally applies a carefully tuned sequence of classical control fields.  But fluctuations in the environment or imperfections in these controls can cause the state of the qubits to change in a way that is different from what was intended, \emph{i.e.}, there are errors in the gate. If the device is fairly stable with time\kcy{cite drift paper} and context\cite{Rudinger2019}, then we can accurately model the gate action using a completely positive, trace-preserving (CPTP) map, $\actual$ acting on the Hilbert space of the target qubits. This map can always be written as $\actual = \error\circ\target$, where $\error = \actual\circ\target^{-1}$ is the \emph{error map}, which is itself CPTP because $\target$ is unitary.

CPTP maps possess a number of useful representations, including Kraus operators\cite{1983}, Choi matrices\cite{Choi1975}, and Jamiolkowsi states\cite{yczkowski2004}. But for the purposes of this article, the \emph{process matrix} representation will be particularly convenient\cite{OBrien2004}, and we shall denote the process matrix associated with a given CPTP map $\target$ with its corresponding calligraphic character, $\tarmat$. For a $d$-dimensional quantum state, the process matrix is a $d^2\times d^2$ matrix. A key feature of process matrices is that they are composable and act through the usual matrix multiplication on the vectorized quantum state:
\begin{align}
	\vectorize{\actual(\rho)}
		&= \actmat\cdot\vectorize{\rho} \\
		&= \errmat\cdot\tarmat\cdot\vectorize{\rho}
\end{align}
The $\mathsf{vec}$ operation is typically performed using a basis of matrix units, for which $\vectorize{\rho}$ would be the column vector obtained by stacking the columns of $\rho$. In this work, however, we shall use a basis of Pauli matrices, defining $P = \left\{I, \sigma_x, \sigma_y, \sigma_z\right\}^{\otimes n}$ as the collection of all $4^n$ $n$-qubit Pauli operators (including the identity).  In this basis,
\begin{equation}
  \vectorize{\rho}_i = \expect{P_i} = \tr\!\left(P_i\; \rho \right),
\end{equation}
and
\begin{equation}
	(\actmat)_{ij} = \tr\!\left(P_i \;\actual\!\left(P_j\right) \right).
\end{equation}
Process matrices written in this Pauli basis are often referred to as \emph{Pauli transfer matrices} \cite{Chow2012}.  Error maps represented in this basis take the particularly nice form,
\begin{equation}\label{eq:process_matrix}
\errmat =
	\left(\begin{array}{c|cccc}
		1 &  & \vec{0}^T & \\ 
		\hline & &  &  \\
		\vec{m} &  & R &  \\
		 &  &  & 
	\end{array} 	
	\right)
\end{equation}
The top row of all trace-preserving (TP) error maps is fixed to $\{1,0,0,0,\cdots\}$ and the remainder of the first column, $\vec{m}$, describes any deviations from unitality, as might arise from amplitude damping \cite{preskill1997lecture}. If the error map is unitary, then the error is called \textit{coherent} and the unital submatrix $R$ is a rotation matrix.  Importantly, if $R$ is diagonal, then the error is Pauli stochastic, with each diagonal entry corresponding to the probability that its associated Pauli error occurs in each application of the gate. \kcy{We might need more here defining coherent noise. There is a lot of literature on this, most of it inconsistent. Try Joel's Estimating the Coherence of Noise (terrible title) and Gottesman's paper on Maximally Sensitive States.}

In what follows it will be useful to define the \emph{error generator}, $\genmat$, associated with a faulty gate: 
\begin{align}
	\errmat 
		&= \exp\left(\genmat\right) \\
	\label{eq:generator}
		&= \identmat_d + \genmat + \frac{1}{2}\genmat^2 + \order{\genmat^3}.
\end{align}
If an implemented gate is relatively close to its target, then the error generator will be small under any of the usual matrix norms, and the Taylor expansion above may reliably be truncated at first or second order. 


\subsection{Mixed Quantum Gates}
\label{sec:mqg}
\noindent Suppose that we have access to an ensemble of distinct implementations, 
$\{\actual_i\}$, of a target gate, $\target$.
Each time the gate is to be applied to the system, we randomly select an implementation from this ensemble such that the probability of drawing $\actual_i$ is $\weight_i$ (and we ensure that $\sum_i \weight_i=1$). This procedure is operationally indistinguishable from always applying the effective channel, 
\begin{align}
	\actual_{\rm eff} &= \sum_i \weight_i \actual_i = \left(\sum_i \weight_i \error_i \right) \circ\target
\end{align}
We call such randomized quantum operations \emph{mixed quantum gates} or MQGs. Error metrics for these MQGs can be computed in terms of their effective error map, 
\begin{equation}
	\label{eq:effective_error}
	\error_{\rm eff} = \sum_i \weight_i \error_i.
\end{equation}
Two important error metrics are the average gate infidelity (AGI), $\AGI$, \kcy{We need a citation for this, and check if it's right! Gives weird answer if E = I. I feel like it should be $(d + \tr(\errmat))/(d+d^2)$. Maybe cite Nielsen's paper, or Horodecki**3.} and the diamond distance to the target (or simply, the \emph{diamond distance}), $\dnorm$ \cite{watrous2018theory}, defined as:
\begin{align}
	\label{eq:def_agi}
	&\AGI(\error) = \frac{d^2 - \tr{\errmat}}{d^2 + d},\\
	\label{eq:def_diamond}
	&\dnorm \left(\error\right)
		= \frac{1}{2} \sup_\rho \vert \vert (\ident_d\otimes \ident_d)(\rho) 
										  - (\error \otimes \ident_d)(\rho) \vert\vert_1,
\end{align}
where $d=2^n$ and $\ident_d$ is the $d$-dimensional identity operator.  In Eq.~\eqref{eq:def_agi}, we have written the AGI for an error map, $\error$, in terms of its associated Pauli transfer matrix, $\errmat$. If the error channel is purely stochastic, then $\dnorm(\error) = \AGI(\error)$, but if the error channel has a unitary component, then the diamond distance will generically be larger than the average gate infidelity \cite{1511.00727}. The diamond distance is subaddative \cite{watrous2018theory} under gate composition, so is particularly useful for constructing bounds on quantum circuit performance: the total variation distance between the outcome probabilities of a faulty and perfect quantum circuit is less than or equal to the sum of the diamond distances for gates that compose the circuit \cite{aharonov1998quantum}.

Because $\AGI$ is linear in the error map, we have:
\begin{equation}
	\AGI\!\left(\error_{\rm eff}\right) = \sum_i \weight_i \,\AGI(\error_i).
\end{equation}
That is, the AGI of the effective error channel is simply the weighted average of the component AGIs, so MQGs provide little benefit for reducing the AGI. However, the diamond distance is a nonlinear function of error map. As we show in the appendix (\ref{sub:diamond_distance_inequality}),
\begin{equation}
	\label{eq:diamond_ineq}
	\dnorm\!\left(\error_{\rm eff}\right) \le \sum_i \weight_i \, \dnorm(\error_i).
\end{equation}
So by mixing various implementations, each with a different error channel, the resulting channel can have a diamond distance error that is less than the diamond distance error of any of the component implementations. 

Campbell \cite{Campbell2017} and Hastings \cite{1612.01011} independently considered these mixed channels using gates constructed with the Solovey-Kitaev algorithm, for which many approximate gate compilations are possible. Campbell showed that, if the error generators of some ensemble of gate compilations form a convex set containing the origin, then one can construct a MQG with quadratically suppressed diamond distance to the target. Explicitly, the weights are chosen such that the error generator is canceled to first order. Using (\ref{eq:effective_error}) and (\ref{eq:generator}), the effective error map for a MQG in terms of the component error generators is,
\begin{align}
	\label{eq:generators_and_effective_error}
	% \errmat_{\rm eff} \simeq \left(\identmat_d + \sum_i \weight_i \genmat_i + \frac{1}{2} \sum_i \weight_i \genmat_i^2\right)
	\errmat_{\rm eff} \simeq \sum_i \weight_i \left(\identmat_d + \genmat_i + \frac{1}{2}  \genmat_i^2\right)
\end{align}
These error generators are linear operators and so are elements of a vector space. If, as Campbell required, the origin lies in their convex hull (see Fig.~\ref{fig:vectorspace}), then there exists a choice for the weights, $\weight_i^*$, such that $\sum_i \weight^*=1$ and,
\begin{align}
	\label{eq:cancel}
	&\sum_i \weight_i^* \genmat_i= 0
	% \mathrm{with}\;&\sum_i \weight_i = 1
\end{align}
When this condition is satisfied, we call the resulting operation a \emph{generator-exact} MQG. 

If the diamond distance error rates of the component gates are bounded by $\alpha$, then Campbell shows that this first-order cancellation of the error generators can ensure that the diamond distance error rate of the MQG is bounded by $\alpha^2$. For gate compilation errors, the error channels are dominated by unitary approximation error, so the error generators are Hamiltonians. Hamiltonian generators can have positive or negative coefficients, so it is possible that the origin may lie in their convex hull. If, however, the error map contains stochastic components, then the condition of Eq.~\eqref{eq:cancel} might be impossible to satisfy. Such errors always have strictly positive probabilities, so the origin can \emph{never} lie in their convex hull. This can be rectified by restricting the sum in Eq.~\eqref{eq:cancel} to only the Hamiltonian component of the generators, or by replacing the exact condition with a minimization, as we discuss in Sec.~\ref{sec:mixed_unitary_processes}. 

\begin{figure}
  \centering
  \includegraphics[width=\columnwidth]{vectorspace.pdf}
  \caption{\textbf{Geometric condition for existence:} A target unitary gate can be implemented a number of ways, each associated with a different error generator, $\genmat_i$. These generators lie in a vector space, which we illustrate as two-dimensional here. a) Four error generators. The origin is not contained in their convex hull, so there are no generator-exact MQGs. b) After including an additional control solution, the convex hull grows to contain the origin, and so a generator-exact MQG exists. }
  \label{fig:vectorspace}
\end{figure}

While generator-exact MQGs can provide a guaranteed suppression of the diamond distance, their effective error channels are unlikely to be a purely stochastic. Second- and higher-order terms in \eqref{eq:generators_and_effective_error} can easily contribute to lingering coherent errors that impact the efficient simulability of the channel. In order to definitively eliminate these coherent errors, we could instead seek weights, $\weight^P_i$, that annihilate the off-diagonal entries of the effective error map. The resulting diagonal error map will be Pauli stochastic. For a single qubit gate, it takes the form,
% \begin{equation}
% 	\errmat_{eff} = 
% 	\left(\begin{array}{@{}ccccc@{}}
% 		\cdot & \cdot & \cdot & \cdot \\ 
%   		\cline{1-1}\cline{3-4}
%     	\multicolumn{1}{|c}{0} & \multicolumn{1}{|c}{\cdot} & \multicolumn{1}{|c}{0} & \multicolumn{1}{c|}{0} \\
%     	\cline{2-2}\cline{3-3}		
% 		\multicolumn{1}{|c}{0} & 0 & \multicolumn{1}{|c}{\cdot} & \multicolumn{1}{|c|}{0}\\
% 		\cline{3-3}\cline{4-4}	
% 		\multicolumn{1}{|c}{0} & 0 & 0 & \multicolumn{1}{|c}{\cdot}\\
% 		\cline{1-3}
% 	\end{array} 	
% 	\right).
% \end{equation}
\begin{equation}
	\errmat_{\rm{eff}} = \sum_i \weight_i^P \errmat_i = 
	\left(\begin{array}{@{}ccccc@{}}
		1 & 0 & 0 & 0 \\ 
    	0 &  p_x & 0 & 0 \\
		0 & 0 &  p_y & 0\\
		0 & 0 & 0 &  p_z\\
	\end{array} 	
	\right),
\end{equation}
where $p_x, p_y$ and $p_z$ are the rates of Pauli $X$, $Y$, and $Z$ errors, respectively. We refer to such channels as \emph{Pauli-exact} MQGs, and the same geometric argument we used in constructing generator-exact MQGs is again applicable here. The off-diagonal elements of the error map form a vector space, so we need only check that the origin is in the convex hull of the vectors of off-diagonal elements for each of the component operations, $\errmat_i$. If the error map contains non-unital components or correlated Pauli stochastic errors (such as $X+Y$), then this strict geometric condition will not hold and no Pauli-exact MQG will exist. However, MQGs that approximate the Pauli-exact condition can be found via the convex programing techniques discussed in Sec.~\ref{sub:off_diagonals}.

% In the remainder of this paper, we will formalize this process, laying out efficient convex programs to both generate a family of unitary controls \kcy{do we do this?} and compute the weights required to yield either type of MQG. We discuss how one might include additional desiderata, including reduced sensitivity to environmental fluctuation as well as limiting the number of native unitaries that participate in the MQG.



% ==============================================================================
% Section: Constructing Useful mixed quantum gates
% ==============================================================================
\section{Constructing mixed quantum gates}
\label{sec:mixed_unitary_processes}
\noindent In this section, we present a methodology for constructing mixed quantum channels, formalizing the intuitive approach discussed above. As mentioned, our method requires two steps. The first is a control synthesis step, in which we construct an ensemble of gate implementations. Campbell and Hastings draw their ensembles from various different gate compilations, but for this work we use utilize quantum optimal control theory. Many standard control-generation algorithms, such as GRAPE \cite{Khaneja2005}, take a random initial guess for the control and iteratively improve it to yield a gate that well-approximates a target. By seeding such algorithms with many initial guesses, one can quickly construct a large ensemble of approximate quantum gates, each with a different error channel. We discuss this approach in some detail in Sec.~\ref{sec:numerical_results}. \kcy{Why should the gates we generate have any error at all? They shouldn't if we know the model. Discuss this here.}

The remainder of this section will assume such a capability for generating a large ensemble of gate implementations, and will focus instead on the second step: constructing a distribution over that ensemble that reduces the coherence of the effective error channel. We will begin by discussing the two broad optimization targets introduced above: i) generator-exact MQGs and ii) Pauli-exact MQGs. We then propose a set of secondary targets that can improve the performance by i) incorporating robustness to drift, ii) targeting low-error-rate solutions, and iii) reducing the number of native unitaries that contribute to the effective channel. 

% In the examples that were discussed, all objective functions were linear, and reduced to finding a collection of controls whose convex hull contained the origin in some high-dimensional vector space. In those cases, the vectors might represent a collection of error generators or the off-diagonal elements of a collection of error maps. As we'll see in Section \ref{sub:adding_robustness}, we can also consider the derivatives of the error generators to minimize the sensitivity of the controls to drift. In this way, we see that by considering the appropriate collection of vectors, we can optimize our MQG for different purposes, and which routine we choose will depend on the quantities we are trying to minimize.

% ==============================================================================
% Section: Generators
% ==============================================================================
\subsection{Convex Programs for Constructing Mixed Quantum Gates}
\subsubsection{Generator-exact MQGs} % (fold)
\label{sub:first_order_generators}
\noindent A compelling reason to construct an MQG is to improve the worst-case performance of a quantum gate. The diamond distance bounds this worst-case performance, and so one might assume minimizing it would be a natural optimization target:
\begin{equation}\label{eq:ddmin}
  \begin{split}
    &\underset{\weight_i\geq0, \sum_i\weight_i=1}{\textbf{minimize}: } \hspace{.5cm} \dnorm\left(\sum_i\error_i \weight_i\right)
  \end{split}
\end{equation}
The diamond distance, however, is a non-linear function that in general requires its own convex optimization to compute\cite{watrous2018theory}. This can dramatically slow down iterative optimizers, and so directly minimizing the diamond distance is a computationally burdensome optimization target. However, for quantum computing purposes the error rates are typically quite small, so we can consider a linearized problem, minimizing the diamond distance at first-order in the effective error generator. As discussed around Eq.~\eqref{eq:cancel}, if the origin lies in in the convex hull of the generators, $\0 \in \mathsf{conv}(\{\genmat_i\})$, then we can construct a generator-exact MQG. In \cite{Campbell2017} Campbell presents an iterative algorithm that, given an oracle able to produce approximate unitary operations, will continually generate controls until the geometric constraint is satisfied and then identify the optimal weighting. 

As discussed in the previous section, the geometric condition illustrated in Fig.~\ref{fig:vectorspace} may not be satisfied, due perhaps to stochastic errors in the generators or possible a situation in which one has access only to $m$ distinct, precomputed gate implementations. In this case, we may simply wish to to identify the MQG with minimum error. A heuristic that is efficiently computable is to minimize the Frobenius norm of the first-order effective error generator:
\begin{equation}\label{eq:frobmin}
  \begin{split}
    &\underset{\weight_i\geq0, \sum_i\weight_i=1}{\textbf{minimize}: } \hspace{.5cm}  \left\vert\left\vert\sum_i \weight_i \genmat_i \right\vert\right\vert_F
  \end{split}
\end{equation}
This optimization problem is equivalent to:
\begin{equation}\label{eq:minimization}
  \begin{split}
    &\underset{\weight_i\geq0, |\weight|_1=1}{\textbf{minimize}: } ||\mathbf{L}\cdot\vec\weight||_2\\
  \end{split}
\end{equation}
Where $\mathbf{L}=\left( \mathsf{col}(\genmat_1) \; \mathsf{col}(\genmat_2) \; \cdots \;  \right)$ is the $d^2\times m$-dimensional matrix of column-stacked error generators and $||\cdot||_2$ is the $\ell_2$ norm. 

The constraints on these optimizations are required to ensure that the weights, $\weight_i$, form a proper probability distribution. Linearly constrained minimization problems with quadratic cost functions are convex and have been proven to be efficiently solvable by, e.g. the ellipsoid method \cite{wright1999numerical, khachiyan}. Many existing convex solver software packages are available that can solve these problems efficiently in practice. \kcy{Need some citations here.}

%In both cases it is clear that we should select the gates with smaller error, i.e. $\{U_{\epsilon}, U_{-\epsilon}\}$, rather than those with larger error, to minimize the multiplicative coefficient on the error. Despite this, literature commonly assumes that all controls are less than some threshold value, below which differences in performance don't matter. \cite{Campbell2017} In realistic scenarios, some controls will have better performance than others, and it is important to select from those controls when able to. We will discuss numerical approaches to solving this Section \ref{sec:norm}.

%Another interesting property of the MQG given in Equation \ref{eq:balanced} is that it maintains its first-order insensitivity even in the presence of drift. In particular, if the control amplitudes that implement these gates drift, they will drift in equal and opposite ways. Thus, the resulting depolarizing channel (see Figure \ref{fig:simple_example}) will have a time-dependent strength, but it will remain first-order insensitivity to the static detuning $\epsilon$. In Section \ref{sec:robustly_mixed} we will provide a method for producing controls that exhibit this robustness to drift to arbitrary order. Given these considerations from this simple example, we will now consider a numerical strategy for generating MQGs.


% subsection first_order_generators (end)

% ==============================================================================
% Section: Off-diagonals
% ==============================================================================

\subsubsection{Pauli-exact MQGs} % (fold)
\label{sub:off_diagonals}
As quantum devices grow in size, it is increasingly expensive to simulate their dynamics. Coherent errors impose a particular burden on classical simulators, as the entire quantum state must be tracked continually. As discussed above, Pauli-exact MQGs can be constructed with vanishing coherent error, enabling the use of much more efficient Pauli stochastic simulators that are able to model significantly more qubits than their vector-state counterparts. \kcy{say something more concrete here and PROVIDE CITATIONS!} Like generator-exact MQGs, the optimal weights can be found efficiently by a convex optimization. 

As above, we assume that we have access to $m$ distinct gate implementations, each of which is associated with its own error matrix, $\errmat_i$. We wish to construct an MQG whose effective error is Pauli-stochastic and is therefore diagonal. This can be done with the following simple minimization:
\begin{equation}\label{eq:minimization2}
  \begin{split}
    &\underset{\weight_i\geq0, \sum_i\weight_1=1}{\textbf{minimize}: } ||\sum_i\weight_i \errmat_i - \mathsf{diag}(\sum_i \weight_i \errmat_i)||_2\\
  \end{split}
\end{equation}
Here $(\mathsf{diag}(\mathcal{A}))_{ij} = \mathcal{A}_{ij}\delta_{ij}$ sets the off-diagonal elements of a matrix to zero. This can be more transparently written as a convex program by constructing the $(d^2-d)\times m$-dimensional matrix, $\mathbf{E}$\amp{Why E?}, whose $i$\textsuperscript{th} column is a vector composed of all of the off-diagonal entries of the error generators $\errmat_i$. \footnote{Exactly \emph{how} the off-diagonal entries are vectorized is unimportant, so long as it is consistent across error matrices.} Eq.~\eqref{eq:minimization2} is then equivalent to 
\begin{equation}\label{eq:minimization3}
  \begin{split}
    &\underset{\weight_i\geq0, |\weight|_1=1}{\textbf{minimize}: } ||\mathbf{E}\cdot\vec\weight||_2
  \end{split}
\end{equation}
The similarity with Eq.~\ref{eq:minimization} is clear and the same methods can be used to solve both.

\kcy{do something with the paragraph}
If the solver routine finds a solution for which the cost function is equal to 0, then the resulting error channel will be \textit{exactly} a Pauli channel. As mentioned, circuits composed of gates with Pauli stochastic error channels can be more efficiently simulated by Monte Carlo methods. Furthermore, if the bare circuit consists of only Clifford gates, stabilizer methods can be used in conjunction with the Monte Carlo methods to give sub-exponential simulation times.\cite{quant-ph/9807006} \kcy{Why this paper?} Other authors have considered the problem of finding the closest Pauli or Clifford Channel to a given process \cite{Magesan2013, Puzzuoli2014}. This protocol can implement gates with errors that are actually Pauli stochastic. \kcy{Discuss randomized compiling here and in the introduction.}\amp{still rough}

% subsection off_diagonals (end)

% ==============================================================================
% Section: Robustness
% ==============================================================================
\subsection{Secondary Objectives}
\noindent 
Often, the cost of generating distinct gate implementations is quite small, so large ensembles of them can be computed rather quickly. It is often the case that one will have available many more distinct gate implementations than there are parameters in the relevant vector space (see Fig.~\ref{fig:vectorspace}). This can lead to the the minimization problems discussed in the previous section being massively under-constrained, yielding a large continuous family of exact solutions. Secondary objectives provide a means for choosing among this family of exact MQGs those with increased performance in a desired area. In this section we present explicit convex programs for such secondary objectives, including adding robustness to drift or model uncertainty, reducing the effective gate error, and minimizing the number of constituent gates utilized by the MQG. We choose to take generator-exact MQGs as our starting point, though the following sections apply equally well to Pauli-exact MQGs with only trivial modifications. 

\subsubsection{Robustness to drift and model uncertainty} % (fold)
\label{sub:adding_robustness}
\noindent 
While mixed quantum gates offer significant performance improvements, their construction assumes a good knowledge of the errors experienced by the constituent gates. But often the gates are not perfectly well characterized. This could be due to simple uncertainty about the parameters of the model used to generate the control solutions, or the system could experience some degree of drift \kcy{cite Tim's drift manuscript}. In either case, the performance of the MQG will be negatively impacted. We can describe the effect of this uncertainty by first writing the gate explicitly as a function of a vector of model parameters, $\vec\lambda$, and their nominal values, $\vec\lambda_0$. These model parameters could include magnetic field strengths, laser or microwave intensities, coupling strengths, etc. If the parameters are close to their nominal values, then we can write a gate's error generator as a Taylor expansion in the deviation vector, $\vec\delta = \vec\lambda-\vec\lambda_0$:
\begin{equation}
	\label{eq:sensitivity_expansion}
	\genmat_i(\vec \delta) = \genmat_i(\0) + \sum_k \delta_k \,\genmat_{i,k}(\0) + \order{\delta^2}.
\end{equation} 
In the above expression we have used the comma derivative, 
\begin{equation}
	\genmat_{i,k}(\vec \delta_0) = \frac{\partial}{\partial \delta_k} \genmat_i(\vec\delta) \vert_{\vec \delta=\delta_0}.
\end{equation}

Combining Eq.~\eqref{eq:sensitivity_expansion} with Eq.~\eqref{eq:generator} and taking both Taylor expansions to first order, we have:
\begin{align}
\notag
	\errmat_{\rm eff} =&
		 \identmat_d + \sum_i \weight_i \left(\genmat_i(0) + \sum_k \delta_k \,\genmat_{i,k}(\0) \right) \\
		 &+ \order{\genmat_i^2 + \genmat_i \delta + \delta^2}.
\end{align}
We would like to choose the weights $\vec\weight$ so that the effective error generator vanishes to first order. We can cast this problem as a convex optimization problem, much as we did in Sec.~\ref{sec:introduction} for synthesizing generator-exact MQGs. Following Eq.~\eqref{eq:minimization}, we have,
\begin{equation}\label{eq:minimization}
  \begin{split}
    &\underset{\weight_i\geq0, |\weight|_1=1}{\textbf{minimize}: } ||\mathbf{L}\cdot\vec\weight||_2 + \sum_k||\mathbf{L}_{,k}\cdot\vec\weight||_2\\
  \end{split}
\end{equation}
Where $\mathbf{L}_{,k}=\left( \mathsf{col}(\genmat_{1,k}(\0)) \; \mathsf{col}(\genmat_{2,k}(\0)) \; \cdots \;  \right)$ is the $d^2\times m$-dimensional matrix of column-stacked derivatives of the error generators with respect to the deviation $\delta_k$.

We can additionally generalize the geometric criterion for guaranteeing the existence of generator-exact MQGs. To construct a robust, generator-exact MQG, there must exist a set of weights, $\{\weight_i\}$, so that $\sum_i \weight_i \genmat_i = \sum_i \weight_i \genmat_{i,k} = 0$. This is equivalent to demanding the origin lie in the convex hull of the generators augmented with their derivatives:
\begin{equation}
\0 \in \mathsf{conv}\left( \left\{
\genmat_i \bigoplus_k \genmat_{i,k}
\right\}_i	 \right).
\end{equation}
We illustrate this in Fig.~\ref{fig:vectorspace2}.

We call a gate constructed in this way a \emph{robust} generator-exact MQG. These techniques can easily adapted to construct robust Pauli-exact MQGs, where vectors of the off-diagonal elements of the error maps take the role of the error generators used above.

\begin{figure}
  \centering
  \includegraphics[width=\columnwidth]{vectorspace3.png}
  \caption{\textbf{Geometric condition for robustness:}   A target unitary gate can be implemented a number of ways, each with a different effective error generator, $\genmat_i$. a) The error generators are shown as elements of a vector space (solid, black arrows). Also shown are their derivatives $\genmat_{i,k}$ (dashed, grey arrows) with respect to a model parameter, $\delta_k$. As this parameter drifts, the generators may no longer cancel. b) To construct a robust, generator-exact MQG, there must exist a set of weights, $\{\weight_i\}$, so that $\sum_i \weight_i \genmat_i = \sum_i \weight_i \genmat_{i,k} = 0$. This is equivalent to demanding that the origin lie in the convex hull $\mathsf{conv}(\{\genmat_i \bigoplus_k \genmat_{i,k} \}_i)$. }
  \label{fig:vectorspace2}
\end{figure}

% subsection adding_robustness (end)

% ==============================================================================
% Section: Norm regularization
% ==============================================================================

\subsubsection{Improving the average gate fidelity}
\label{sec:norm}
\noindent While the geometric constraint is sufficient for suppressing the diamond norm to first order relative to the \textit{worst} controls in the collection, it does not preferentially select the best controls possible.  As an example, consider four erroneous implementations of a Pauli $Z$ gate: $Z_{-2\theta}$, $Z_{-\theta}$, $Z_{\theta}$, and $Z_{2\theta}$, where the subscript indicates the magnitude of the $Z$-rotation error. An MQG consisting of equally weighted $Z_{-2\theta}$ and $Z_{2\theta}$ is generator-exact, as is $Z_{-\theta}$ and $Z_{\theta}$. But the error rate\footnote{The diamond distance is equal to the AGI here.} of the first is $~4\theta^2$, while the second achieves an error rate of $\theta^2$. 

To incentive the inclusion of controls with smaller error, we may instead minimize the average gate infidelity of the mixed quantum gate, subject to the condition that any solution we find be generator-exact:

\begin{equation}\label{eq:agi_minimization_constrained}
  \begin{split}
    &\underset{\weight_i\geq0, |\weight|_1=1}{\textbf{minimize}: } \sum_i \weight_i\; \AGI(\errmat_i)\\
    & \textbf{subject to}: ||\mathbf{L}\cdot\vec\weight||_2 = 0 
  \end{split}
\end{equation}

If we do not expect to have a space of generator-exact solutions available, then the constraint above will never be satisfied and the minimization will fail. This could occur if there are simply not enough controls to satisfy the generator-exact criterion, or if the error generators have stochastic components. In such a case, we can choose a weighting parameter, $\eta$, to explicitly balance the two competing objectives:

\begin{equation}\label{eq:agi_minimization_weighted}
  \begin{split}
    &\underset{\weight_i\geq0, |\weight|_1=1}{\textbf{minimize}: } ||\mathbf{L}\cdot\vec\weight||_2  + \eta \sum_i \weight_i\; \AGI(\errmat_i)
  \end{split}
\end{equation}

Both optimizations are convex and efficiently solvable. 

% then we can instead incentivize the construction of a lowest-error MQG by including an AGI penalty directly in the 

% \begin{equation}\label{eq:minimization}
%   \begin{split}
%     &\underset{\weight_i\geq0, |\weight|_1=1}{\textbf{minimize}: } \sum_i \weight_i\; \AGI(\errmat_i)\\
%     & \textbf{subject to}: ||\mathbf{L}\cdot\vec\weight||_2 = 0 
%   \end{split}
% \end{equation}


% \begin{equation}\label{eq:minimization_l2}
% \begin{split}
% & \ \bunderbrace{\textbf{minimize}: }{\weight_i\geq0, |\weight|_1=1} ||{\mathbf{D}^{\ell}}\weight||_1+ \eta\sum\weight_i||D^0_i||_2\\
% &\ \ \textbf{subject to: } \forall n<\ell, ||\sum \weight_iD_i^n||=0\\
% \end{split}
% \end{equation}
% with $\eta \geq 0$. By increasing $\eta$, we can encourage the optimizer to include better controls while minimizing the diamond norm. The value of $\eta$ that is best for any particular problem instance will depend on the values in $\mathbf{D}^\ell$.

%Naively generating the 1Q 0MQG in the previous section results in nontrivial support on all the members of the control family. However, as we will see in the next section, we can rewrite the minimization to impose a sparsity constraint, and the resulting 0MQG uses just five of the controls. 
% ==============================================================================
% Section: Sparsity
% ==============================================================================

\subsubsection{Sparsity Constraints}
\label{sec:sparsity}
As a practical consideration, we would also like to regularize our objective function to promote sparse weightings. Control electronics often have a limited amount of waveform memory, and thus it is important to be able to construct MQGs as few constituent gates as possible. In many machine learning contexts, lasso regularization \cite{tibshirani1996regression} can be used to enforce sparsity in solutions. Rather than penalizing the $\ell_0$ norm of the solution, which is not convex, lasso regularization penalizes the $\ell_1$, which is the convex relaxation of the $\ell_0$ norm. However this is insufficient for our purposes, as we require $\weight$ to be a valid probability distribution, which constrains the $\ell_1$ norm to be equal to $1$. Conveniently, the problem of enforcing sparsity in such situations has been considered in \cite{NIPS2012_4504} and can be expressed via another convex program that extends (\ref{eq:robust_minimization}):

\kcy{Make the rest of this section consistent with the current notation.}
\begin{equation}\label{eq:minimization_regularization}
\begin{split}
&\underset{m\in[N]}{\textbf{minimize}}\\
&\ \ \bunderbrace{\textbf{minimize}: }{\weight_i\geq0, |\weight|_1=1,\\ t\geq0} ||{\mathbf{D}^{\ell}}\weight||_1 + t\\
&\ \ \textbf{subject to: } \weight_m > \frac{\lambda}{t}\\
&\ \ \phantom{\textbf{subject to: }} \forall n<\ell, ||\sum \weight_iD_i^n||=0
\end{split}
\end{equation} with $\lambda\geq0$. As with $\eta$ in the last subsection, the optimal value of $\lambda$ is problem specific, depending on $\mathbf{D}^\ell$ and how sparse the solution needs to be. In the following sections we discuss both experimental and numerical implementations of MQGs, leveraging these optimization techniques. 


% ==============================================================================
% Section: Results
% ==============================================================================
\section{Results} % (fold)
\label{sec:results}

% ==============================================================================
% Section: Experimental Results
% ==============================================================================

\subsection{Experimental implementation} % (fold)
\label{sub:experimental}
\noindent We implemented our methods using the 19Q-Acorn superconducting transmon processor at Rigetti Computing. Comprehensive device characterization for this processor can be found in \cite{1712.05771}. While this device consisted of 20 qubits with fixed couplings, we used only qubit \#8 for our demonstration. Controls were derived from a single, 10-sample, 50ns Gaussian $X_{\pi/2}$ pulse calibrated by iteratively amplifying and correcting over- and under-rotation errors via repeated application. Four intentionally miscalibrated Gaussian pulses, labeled $\mathsf{Pulse1}$ through $\mathsf{Pulse4}$, were derived from this waveform by scaling the amplitude of the calibrated $X_{\pi/2}$ pulse by $106.4\%$,  $103.9\%$, $93.7\%$ and $91.2\%$. The gates therefore experience unitary over/under rotations, which are coherent errors. These gates are then used as in Sec.~\ref{sub:off_diagonals} to construct a Pauli-exact MQG, which samples from the miscalibrated waveforms with probabilities, \kcy{What are they?}\amp{I'll have to go hunting, I didn't save these}, respectively. 

We characterize the performance of the MQG using a series of randomized benchmarking (RB) experiments\cite{Magesan2011}: one for each of the miscalibrated pulses, one using the calibrated pulse, and using the MQG. In each case, the Clifford operations were decomposed into $X_{\pi/2}$ gates, which were implemented directly using the relevant waveforms, and $Y_{\pi/2}$ gates, which were implemented by phase-shifting the relevant waveform $\pi/2$ radians.  An RB experiment consisted of $10$ sequences sampled at each of lengths $\{2, 4, 8, 16, 32, 64\}$, and each sequence was repeated $1000$ times. We emphasize that, when benchmarking the MQG, each sequence repetition used a new, randomly sampled sequence of waveforms consistent with its definition.  Results of the standard RB analysis are indicated in Table.~\eqref{tabl:rb}. The MQG is seen to perform nearly as well as the calibrated pulse, and better than any of the constituent pulses individually.  

Figure \ref{fig:rb} illustrates the distribution of survival probabilities at sequence length $L=64$ for each of the experiments. 

\setlength{\tabcolsep}{0.5em} 
{\renewcommand{\arraystretch}{1.2}
% \newcolumntype{d}[1]{D{.}{.}{#1}}
\begin{table}[h]
	\label{tabl:rb}
	\centering
	\begin{tabular}{@{}ccc@{}}
		\hline
		Pulse name & Calibration error & RB error rate\\
		\hline
		$\mathsf{Pulse1}$ 	& 6.4\% 	& 1.1\% \\
		$\mathsf{Pulse2}$ 	& 3.9\% 	& 0.9\% \\
		$\mathsf{Pulse3}$ 	& --\,6.3\% 	& 1.1\% \\
		$\mathsf{Pulse4}$ 	& --\,8.8\% 	& 1.5\% \\
		Calibrated 			& $\cdot$  	& 0.7\% \\
		MQG 				& $\cdot$ 	& 0.8\% \\
		\hline
	\end{tabular}
	\caption{\textbf{Randomized benchmarking results:} The MQG outperforms all of the individual miscalibrated gates of which it is composed, achieving an RB number nearly as low as the carefully calibrated pulse. }
\end{table}

By minimizing the off-diagonal elements of the process matrix, we expect the resulting MQG to display suppressed coherent error. To see that this is in fact the case, we can inspect the variance of the $RB$ survival probabilities for the MQG relative to the miscalibrated pulses. As discussed in \cite{Ball2016}, coherent errors will tend to broaden the distribution of RB survival probabilities over sequences at each length, generally manifesting as a long-tailed gamma distribution. Stochastic noise, such as depolarizing noise, will yeilds relatively narrow, Gaussian distributed success probabilities. In Fig.~\ref{fig:rb}, we plot the distribution of survival probabilities at sequence length $64$ for each of the benchmarked gate sets. We see that the intentionally miscalibrated controls in our RB experiment have long tails, consistent with coherent noise, while the calibrated and randomized implementations are both significantly less dispersed, consistent with stochastic errors. This experiment therefore provides compelling evidence that the MQG suffers considerably less coherent error than any of the miscalibrated gates from which it was constructed.


\begin{figure}[t]
  \centering
  \includegraphics[width=\columnwidth]{rb_data.pdf}
  \caption{\textbf{MQGs improve randomized benchmarking:}. The first four boxes result from using each of four different implementations of the ${\pi/2}$ rotations. The coherent noise present in these implementations leads to large variance of the survival probability over sequences. The fifth (dark blue) box illustrates the survival probability using a highly-tuned gate implementation. It displays improved average survival probability as well as reduced variance. The final box (dark red) illustrates the distribution over survival probabilities for a randomized MQG composed of $\mathsf{Pulse1}$ through $\mathsf{Pulse4}$. It performs comparably to the highly-calibrated implementation in both average survival probability and variance over random sequences. The reduced variance of the MQG is a tell-tale sign of reduced coherent error in the effective channel. }
  \label{fig:rb}
\end{figure}

We note that, while this example is somewhat contrived (the calibrated gate is clearly the best), it nonetheless succeeds in demonstrating that the MQGs are capable of outperforming the individual gates of which they are composed. In future work, we hope to apply this technique to two-qubit gates, which are harder to tune up in general and are more likely to possess lingering coherent errors \needcite. 

% subsection experimental (end)


% ==============================================================================
% Section: Numerical Results
% ==============================================================================
\subsection{Numerical Implementation}
\label{sec:numerical_results}
\noindent In the following numerical results, we use the methods in Section \ref{sec:mixed_unitary_processes} to build MQGs, and then analyze their performance for a range of Hamiltonian parameters. More specifically, we will construct a family of controls with some degree of inherent robustness to drift, and leverage the numerical techniques introduced to assign each control a probability. When drawn from with these probabilities, the controls will form an MQG with enhanced robustness to drift on the control parameters. We consider the following dimensionless model for a single tunable qubit: 
\begin{equation}\label{eq:1Qham}
  H(\delta, \epsilon, t) = \epsilon\sigma_z + (1 + \delta)(c_x(t)\sigma_x + c_y(t)\sigma_y)
\end{equation}
where $\epsilon$ corresponds to fluctuations in qubit frequency and $\delta$ corresponds to fluctuations in the control field.

To generate the initial controls, we use the GRAPE algorithm\cite{Khaneja2005} with N=25 steps and total evolution time of $\pi$ to generate 100 candidate controls. However, by imposing the sparisty constraint discussed in Section \ref{sec:sparsity}, we found MQGs consisting of just 10 controls. In our implementation of the GRAPE algorithm, we use the performance function presented in \cite{Khaneja2005}, and average over different values of $\delta$ and $\epsilon$ using Gaussian quadrature when computing the gradient, so that we find controls that are naturally robust. The standard deviations considered for all parameters in our numerical experiments were fixed to $\sigma=.001$. Finally, we assume that the errors on $\sigma_x$ and $\sigma_y$ are perfectly correlated, as in our experimental implementation. We note that advanced quantum control protocols may provide an even more principled approach to control synthesis. DMORPH \cite{dominy2008exploring}, for example, explores continuous families of controls on fidelity level sets, thereby enabling further optimizations against secondary criteria, such as the duration of the control pulse or robustness to drift. 

Using controls generated in this way, the MQGs produced for $X_{\pi/2}$ and $Y_{\pi/2}$ are qualitatively similar, with the results for $X_{\pi/2}$ shown in Figure \ref{fig:YMQG}. By imposing the penalty from Section \ref{sec:norm}, we sought to ensure that the algorithm preferentially selected controls with smaller errors. Adding this constraint increased the performance of the 0MQG by nearly an order of magnitude at the origin, and produced a 1MQG whose performance is an order of magnitude better than the 0MQG away from the origin. Imposing this constraint allows us to trade off flatness for performance. This shows that through adding constraints to our optimization routine, we can make the MQG practically useful. 

\begin{figure}[h]
  \centering
  \includegraphics[width=\columnwidth]{figures/1q_robustness_delta.pdf}
  \caption{\textbf{One-qubit robust MQG} Numerical results showing the the diamond distance errors for a generator-exact MQG (dashed blue), a robust generator-exact MQG (solid orange), and a large set of bare unitary controls (thin solid grey) as a function of a the fractional amplitude error. The target is an $X_{\pi/2}$ gate on a single tunable \kcy{the model doesn't indicate that it is tunable - double check the x axis is correct} qubit. The generator-exact MQGs dramatically outperforms both the robust MQG and any of the bare unitaries at $\delta=0$. However, even a relatively small amplitude error leads to a regime in which the the robust MQG will yield the better gate. Similar results are obtained for drift in the qubit frequency.}
  \label{fig:YMQG}
\end{figure}

In our two-qubit example we consider the following model for two tunable qubits coupled by a resonant exchange interaction, similar to that in \cite{McKay2016}:
\begin{equation} \label{eq:2Qham}
\begin{split}
H(\vec{\delta}, \vec{\epsilon}, t) = &\sum_{j=1}^2(\epsilon_j\sigma_z^j + (1 + \delta_j)(c_x^j(t)\sigma_x^j + c_y^j(t)\sigma_y^j)) \\
&+ \frac{1}{10}(XX + YY)
\end{split}
\end{equation}

\amp{This section is still tough to read, but I'm not sure of a better way to handle it. The constituent controls are clearly contrived, so I think it best to be explicit about how they were constructed.}In this example it was infeasible to use GRAPE to return non-trivial solutions. Instead we manually selected piecewise constant echoing sequences with 500 steps and total evolution time of $\frac{5\pi}{2}$. In particular, we considered $RX(\pi)$, $RX(-\pi)$, $RY(\pi)$ and $RY(-\pi)$ bang-bang sequences \cite{bangbang}, consisting of all combinations of simultaneous $\pi$ pulses activated at multiples of $8$ steps from the beginning of the controls, and the same multiple of $8$ steps prior to the end of the controls. To give the control family a variety of RF errors, we also added uniformly distributed amplitude errors to each $\pi$ pulse, between $-.25$\% and $.25$\%.

In this example, we find more modest improvements to performance, as shown in Figure \ref{fig:2MQG}. There are now four free parameters to optimize over, and the uncontrolled entangling interaction means that there is little room for variation in the controls. Nonetheless, using an MQG improves performance by half an order of magnitude at the origin relative to the constituent controls, and up to an order of magnitude away from the origin. For all values of the drifting parameters we see that the 1MQG performs as well or better than 0MQG.

\begin{figure}
  \centering
  \includegraphics[width=\columnwidth]{figures/2q_robustness.pdf}
  \caption{\textbf{Two-qubit robust MQG} Numerical results showing the the diamond distance errors for a generator-exact MQG (dashed blue), a robust generator-exact MQG (solid orange), and a large set of bare unitary controls (thin solid grey) as a function of a spurious detuning (quantified by the ratio of the detuning to the maximum control amplitude). It is intended to models a pair of tunable qubits interacting via resonant exchange. Both MQGs can be seen to outperform the bare unitary control over a wide range of detunings. The robust MQG performs always outperforms the generator-exact MQG, and both MQGs outperform any of the bare unitary controls over a wide range of detunings. Similar results are obtained for drift in the qubit control amplitude.}
  \label{fig:2MQG}
\end{figure}






% ==============================================================================
% Section: Conclusion and Future Work
% ==============================================================================


\section{Conclusion and Future Work}
We have shown numerically that using MQGs can reduce coherent error by more than an order of magnitude in diamond norm, over a wide range of quasi-static values of noise. In addition, we have demonstrated that these approximate controls can be generated through optimal control (GRAPE), and that the minimization problem is tractable.

Randomized protocols have a long history of outperforming their deterministic counterparts. In \cite{Viola2005, Santos2006} the use of randomness is discussed in the context of dynamical decoupling. In particular, it is shown that both stochastic and hybrid approaches can result in better or more tractable coherent controls. Additionally Pauli Frame Randomization\cite{Wallman2016} has been shown \cite{1803.01818} to reduce coherent errors by introducing randomness in a pre-compilation step. The techniques discussed in this paper are different from both of these approaches in that they explicitly produce incoherent errors through mixing, and that the randomness is hardware efficient for any desired gate.

Future directions for this work include demonstrating the routine experimentally on a two-qubit gate, moving the random gate selection from a pre-compilation \kcy{this needs to be explained in the experimental section} step to runtime logic onboard the control electronics, investigating other optimization routines such as CRAB \cite{Caneva2011} and GOAT\cite{Machnes2018}, and using more sophisticated benchmarking routines such as GST\cite{BlumeKohout2017} to quantitatively investigate the performance of our method.

That these methods depnd on accurate system models is a clear shortcoming. The robust MQG The numerical work in the paper assumes access to a model of the system, however an experimentalist may not have a model readily available to describe the system, e.g. in the presence of unknown on-chip crosstalk, or an uncalibrated transfer function of the system. Even if a model is available, it might be computationally inconvenient to simulate, i.e. for more than a few qubits. In these situations, one approach would be to use \textit{in-situ} optimal control techniques \cite{Wu2018, Kelly2014, Ferrie2015} to generate candidate controls, and then use an optimizer like Nelder-Mead to perform the minimization. While performing a complete optimization in this way would require full process tomography, one could instead optimize via partial tomography. By selecting pre-- and post --rotations that correspond to measuring Pauli-moments of interest in the Hamiltonian, such as unwanted $Z\otimes Z$ crosstalk, one could perform optimization over fewer parameters.

Crosstalk, two qubit gates, etc. 


% ==============================================================================
% Section: Acknowledgements
% ==============================================================================

\section{Acknowledgements}
\label{sec:acknowledgements}
This material was funded in part by the U.S. Department of Energy, Office of Science, Office of Advanced Scientific Computing Research Quantum Testbed Program, as well as by Sandia National Laboratories' Laboratory Directed Research and Development program. Sandia National Laboratories is a multimission laboratory managed and operated by National Technology and Engineering Solutions of Sandia, LLC, a wholly owned subsidiary of Honeywell International, Inc., for the U.S. Department of Energy's National Nuclear Security Administration under contract DE-NA0003525.
\bibliography{mixed_unitaries.bib}

% ==============================================================================
% Section: Appendix
% ==============================================================================
\section{Appendix}
\label{sec:appendix}

% ==============================================================================
% Section: Diamond Distance Inequality
% ==============================================================================
\subsection{Proof of diamond distance inequality}
\label{sub:diamond_distance_inequality}
Here we prove the claim of \eqref{eq:diamond_ineq} that:
\begin{equation}
	\dnorm\!\left(\error_{\rm eff}\right) \le \sum \weight_i \, \dnorm(\error_i).
\end{equation}
The effective error channel for a mixed quantum gate is $\error_{\rm{eff}} = \sum \weight_i\,\error_i$, where $\error_i$ are the error channels for the component gates. The diamond distance to the identity of the effective error channel is:
\begin{align}
	\dnorm \left(\error_{\rm eff}\right)
		&= \frac{1}{2} \sup_\rho \vert \vert (\ident_d\otimes \ident_d)(\rho) 
										  - (\error_{\rm eff} \otimes \ident_d)(\rho) \vert\vert_1\\
		% &= \frac{1}{2} \sup_\rho \vert \vert (\ident_d\otimes \ident_d)(\rho) 
										  % - (\sum_i \weight_i\,\error_i \otimes \ident_d)(\rho) \vert\vert_1 \\
		&= \frac{1}{2} \sup_\rho \vert \vert \sum \weight_i\,((\ident_d
										  - \error_i) \otimes \ident_d)(\rho) \vert\vert_1
\end{align}
For qubits, the space of density matrices is compact, so the supremum is achievable. Call a state that achieves the supremum $\rho^*$. Then 
\begin{align}
	\dnorm \left(\error_{\rm eff}\right)
		&= \frac{1}{2} \vert \vert \sum \weight_i\,((\ident_d
										  - \error_i) \otimes \ident_d)(\rho^*) \vert\vert_1 \\
		&= \frac{1}{2} \vert \vert \sum \weight_i\, \rho^*_i \vert\vert_1,
\end{align}
where we have defined $\rho^*_i = ((\ident_d - \error_i) \otimes \ident_d)(\rho^*)$. The nuclear norm above is equal to the sum of the singular values of $\sum \weight_i \rho_i$. Using the Ky Fan singular value inequality \cite{fan1951maximum} , we have 
\begin{align}
	\dnorm \left(\error_{\rm eff}\right)
		&\le \frac{1}{2} \sum_i \weight_i \vert \vert \rho^*_i \vert\vert_1 \\
		&\le \sum_i \weight_i\, \dnorm(\error_i)
\end{align}
The second inequality above follows because $\rho^*$ defines an explicit lower bound for the diamond distance for each of the component error maps. 

\end{document}
