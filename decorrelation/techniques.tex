%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% RevTeX 4.1 LaTeX
% Kevin C. Young
% Scalable & Secure Systems Research (08961)
% Thu Mar  5 15:29:19 PST 2015
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[aps,nofootinbib,pra,notitlepage,twocolumn]{revtex4-1}
\usepackage{amsfonts,amsmath,amssymb,amsthm}
\usepackage{array,bm,color}
\usepackage{epsfig,graphicx,nomencl,revsymb4-1,upgreek,url}
\usepackage{hyperref}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{graphicx}
\graphicspath{{./figures/}}
\hypersetup{colorlinks=true, pdfauthor=Kevin C. Young, pdftitle=Decorrelating Errors}
\newcommand{\tr}{{\rm Tr\thinspace}}
\newcommand{\bra}[1]{\ensuremath{\left\langle{#1}\right\vert}}
\newcommand{\ket}[1]{\ensuremath{\left\vert{#1}\right\rangle}}
\newcommand{\braket}[2]{\left\langle #1 | #2 \right\rangle}
\newcommand{\ketbra}[2]{\left| #1 \right\rangle\!\!\!\,\left\langle #2 \right|}
\newcommand{\abs}[1]{\left\vert #1 \right\vert}
\newcommand{\expect}[1]{\ensuremath{\left\langle{#1}\right\rangle}}
\newcommand{\timeorder}{\ensuremath{\underset{\leftarrow}{\mathcal{T}}}}
\newcommand{\ident}{{\mathbb1}}
\newcommand{\order}[1]{\mathcal{O}\left( #1 \right)}
\newcommand{\diag}[1]{\mathrm{diag}\{#1\}}
\newcommand{\trans}[1]{#1^\mathsf{T}}
\newcommand{\T}{\mathsf{T}}
\newcommand{\erf}[1]{Eq.~(\ref{#1})}
\newcommand{\needcite}{{\color{blue}\textsuperscript{[citation needed]}}}
\newcommand{\note}[1]{{\color{red}[#1]}}
\newcommand{\kcy}[1]{{\color{red}[#1]_{\rm{KCY}}}}
\newcommand{\amp}[1]{{\color{red}[#1]_{\rm{AMP}}}}
\setlength{\jot}{10pt}
\newtheorem{thm}{Theorem}[section]
\newtheorem{lem}[thm]{Lemma}
\usepackage{lipsum}

\begin{document}

\section{Choose your own adventure}
\subsection{1Q}
In the numerics and experiments run in this paper, a variety of of techniques were employed to guide the convex solver to desired solutions. In the one qubit examples we enforced sparsity using the convex optimization problem defined in \cite{NIPS2012_4504} so that the 0RBCs generated would have non-trivial support on only 10 of the 500 controls used. In addition we added a hyperparameter to penalize for the l1 norm of the constituent Hamiltonians. This was used in the 1RBCs for the one qubit controls so that we could trade off some of the insensitivity of the 1RBC for better performance at the origin.

Both the 0RBC and the 1RBC in the one qubit examples were constructed by solving the following equation using MOSEK:
\begin{equation}\label{eq:minimization}
  \begin{split}
    &\underset{\omega_j\geq0, |\omega|_1=1}{\textbf{minimize}: } ||D_{\ell}^T\omega||\\
    &\textbf{subject to: } \forall i<\ell, \sum \omega_jD_j^i=0\\
  \end{split}
\end{equation}

The elements of the one qubit control families were generated using the GRAPE algorithm with N=25 steps and total evolution time of $\pi$. The performance function used to terminate the gradient descent was equation (30) in Khaneja's paper - the square of the Hilbert-Schmidt inner product between the GRAPE unitary and the target unitary. The gradient, however, is the gaussian quadrature gradient described in the main text. In particular, using degree two (which should be accurate for polynomials up to degree 3) Gauss-Hermite quadrature we evaluated the gaussian weighted average gradient for a $\sigma=.001$, on both the qubit drive, and the qubit frequency. 
\subsection{2Q}
In the two-qubit case the situation was more difficult - GRAPE would not return non-trivial solutions so we manually selected piecewise constant sequences with 500 steps and total evolution time of $\frac{5\pi}{2}$. We then prepared 1024 controls.  In this case, we treated the $RX(\pi)$, $RX(-\pi)$, $RY(\pi)$ and $RY(-\pi)$ pulses used to decouple the tuning errors as taking only one time step, to avoid significant errors arising from mixing the eigenspaces of the interaction term. The particular collection of bang-bang sequences considered were all combinations of of simultaneous $\pi$ pulses activated at multiples of $8$ steps from the first time step, and the same multiple of $8$ steps prior to the last time step. To give the control family a variety of different errors, we added on uniformly distributed errors to each $\pi$ pulse, between $-.25$\% and $.25$\%. We did not apply the sparsity constraint, or any $\ell 1$ constraints to the solutions, we only applied the minimization problem defined earlier in this document.
\subsection{Experimental}
For the experimental data the four controls generated were generated by scaling an approximately calibrated 50$\mu$s Gaussian $\pi$ pulse by $106.4\%$,  $103.9\%$, $93.7\%$ and $91.2\%$. Then, using a naive driven qubit model (no noise), we predicted the unitaries that these pulses would generate, calculated their error maps, and used COBYLA in scipy minimize to minimize the off-diagonal elements of the mixed channel. Using the weights returned from that, we ran a randomized benchmarking experiment, with the details listed in the main document.
\end{document}