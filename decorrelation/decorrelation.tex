%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% RevTeX 4.1 LaTeX
% Kevin C. Young
% Scalable & Secure Systems Research (08961)
% Thu Mar  5 15:29:19 PST 2015
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[aps,nofootinbib,pra,notitlepage,twocolumn]{revtex4-1}

\usepackage{amsfonts,amsmath,amssymb,amsthm}
\usepackage{array,bm,color}
\usepackage{epsfig,graphicx,nomencl,revsymb4-1,upgreek,url}
\usepackage{hyperref}
\usepackage{algorithm}
\usepackage{algpseudocode}
\hypersetup{colorlinks=true, pdfauthor=Kevin C. Young, pdftitle=}
%\hypersetup{citecolor={blue}, colorlinks={true}, filecolor={blue},
%   linkcolor={blue}, pdfauthor=, pdfkeywords= pdfsubject=, pdftitle=,
%   urlcolor{blue}}



\newcommand{\tr}{{\rm Tr\thinspace}}
\newcommand{\bra}[1]{\ensuremath{\left\langle{#1}\right\vert}}
\newcommand{\ket}[1]{\ensuremath{\left\vert{#1}\right\rangle}}
\newcommand{\braket}[2]{\left\langle #1 | #2 \right\rangle}
\newcommand{\ketbra}[2]{\left| #1 \right\rangle\!\!\!\,\left\langle #2 \right|}
\newcommand{\abs}[1]{\left\vert #1 \right\vert}
\newcommand{\expect}[1]{\ensuremath{\left\langle{#1}\right\rangle}}
\newcommand{\timeorder}{\ensuremath{\underset{\leftarrow}{\mathcal{T}}}}
\newcommand{\ident}{{\mathbb1}}
\newcommand{\order}[1]{\mathcal{O}\left( #1 \right)}
\newcommand{\diag}[1]{\mathrm{diag}\{#1\}}
\newcommand{\trans}[1]{#1^\mathsf{T}}
\newcommand{\T}{\mathsf{T}}

\newcommand{\erf}[1]{Eq.~(\ref{#1})}
\newcommand{\needcite}{{\color{blue}\textsuperscript{[citation needed]}}}
\newcommand{\note}[1]{{\color{red}[#1]}}
\newcommand{\kcy}[1]{{\color{red}[#1]_{\rm{KCY}}}}

%-------------Header begins here----------------------------------------
\begin{document}
\title{Decorrelating Errors in Quantum Gates by Random Gate Synthesis}

\author{Anthony Polloreno}
% \email[Email: ]{apolloreno}
\affiliation{Rigetti Computing, Berkeley, CA}

\author{Kevin C. Young}
\email[Corresponding author: ]{kyoung@sandia.gov}
\affiliation{Sandia National Laboratories, Livermore, CA}

\date{\today}

\begin{abstract}
Thresholds for fault-tolerant quantum computation are often calculated assuming a noise model in which errors are uncorrelated. While convenient for simulation, these error models are often unphysical. Work by Preskill and others has shown that arbitrarily long computations may be performed even in the presence of spatial correlation, provided the correlation is sufficiently weak and decays sufficiently quickly with distance, but at the cost of a significantly lower threshold. The success of algebraic decorrelation methods, such as dynamical decoupling, demonstrate that quantum control techniques are capable of reducing temporal noise correlations. We propose to introduce similar methods to effect the spatial decorrelation of errors in quantum circuits, thereby increasing the threshold for fault-tolerant computation in such systems.
\end{abstract}

\pacs{}

\maketitle

\section{Introduction}

Steady progress has been made in the theory of quantum error correction, proving higher thresholds for increasingly general models of noise \cite{Aharonov2006}\needcite. These results show that quantum computation is feasible, however recent NISQ \cite{Preskill2018} devices have noise that is not only often above thresholds\needcite, but that also violates fundamental assumptions made by the models used in these results, such as Markovianity \cite{Kitaev1997} and independence of errors \needcite. With these assumptions violated, promises about system performance and correctness are difficult to make.

%As an example, many models assume that errors are local, however systems can have spatially correlated error on more than two qubits that arise from multi-qubit terms in the Hamiltonian, such as:
%\begin{equation}\label{eq:0}
%  H(t) = \sum_{n}\sum_{i}\sum_{j=x,y,z} a^{\textbf{i}}_{\textbf{j}}(t)(\sigma_{j_1}^{i_1}\otimes\sigma_{j_2}^{i_2}\otimes ... \otimes \sigma_{j_n}^{i_n})
%\end{equation}
%where $a^{\textbf{i}}_{\textbf{j}}$ is a stochastic process. In a standard nearest-neighbors topology, like those found in super-conducting qubit architectures, these terms might arise from an effective model where high-frequency degrees of freedom are intergrated out to yield high-weight operators. These noise channels are one way in which the assumptions used in proofs of thresholds may be violated.

There are many ways in which devices can behave in non-Markovian ways,\cite{Kelly2018, BlumeKohout2017}, and even if a system is Markovian, many models make simplifying assumptions about the noise on that system - such as positing that it has a simple structure. For instance Pauli channels are often chosen\needcite due to their classical simulability\needcite. Some authors have then taken the approach of using these easily-understood models to upper bound the error in a real system by \textit{honestly} representing them \cite{Puzzuoli2014}. This approach is correct and rigorous, but scales poorly.

Other authors have tried to address these problems \cite{Wallman2016, Campbell2017, Heim2016} by using circuit composition to remove correlated noise. Given a process that is generated by a sequence of channels with some unknown, potentially channel depdenent error, coherent errors can be averaged away into incoherent error, at the cost of additional compilation steps, which may in general increase circuit depth and require more sophisticated classical preprocessing. Some of these routines have been demonstrated experimentally \cite{Ware2018}, and been shown to reduce the coherence of noise.


%A common feature of these routines is that take advantage of the fact that processes are generally enacted as a sequence of gates. By inserting a potentially expensive classical pre-compilation step, they can exploit sequence structure of a process to average away coherent error. In the case of \cite{Campbell2017}, the analysis takes the point of view of treating Pauli and Clifford gates as being free, which is out of reach of modern quantum computers\needcite. In \cite{Wallman2016} and the implementation in \cite{Ware2018}, the random frames are implemented in each sequence by precompiling the inserted Pauli frame rotations with the Clifford operations. In general, this cannot be done efficiently for non-Clifford operations, and there for this routine is demanding given the severe circuit depth constraints of modern quantum computers.\needcite

In this Letter, we take a different approach to address these problems at the gate synthesis level. We propose to inject additional decorrelating randomness into the system through the use of \emph{balanced control solutions} (BCSs). BCSs are families of control solutions that all approximate the same target gate, but with balanced errors for any given instance of the noise Hamiltonian. That is, for a target gate, $U_T$, we seek a family of control solutions, $c_i(t)$, each implementing an approximation $U_i$ to the target gate, such that the family of unitary approximations is \emph{balanced}. A balanced family is one which satisfies, for some small $\alpha$,
\begin{equation}\label{eq:1}
  \frac{1}{N}\sum_{i=1}^N \omega_i U_i \rho U_i^\dagger = DPN[\alpha]\left(U_T \rho U_T^\dagger \right)
\end{equation}

Where $DPN[\alpha](\rho)$ is a \textit{generalized} depolarizing noise channel with strength $\alpha$. (For the rest of this paper, we will refer to them just as depolarizing channels.) Such a channel is defined as:
\begin{equation}\label{eq:2}
  DPN[\alpha](\rho) \rightarrow (1-\alpha)\rho + \alpha\sum p_i \sigma_i\rho\sigma_i
\end{equation}
with $p_i$ summing to one. This means that on average, the unitary approximations implement the target unitary followed by a small depolarizing channel. The task of constructing the BCSs will fall to optimal control.

This techique can be used to turn coherent error into incoherent error therefore correlated error into uncorrelated error. One benefit of this is that non-Markovian noise will be made to be more Markovian. This is particularly useful because many routines exist that can assess the quality of a gateset, however in the presence of non-Markovianity most of them become unreliable.

For example, randomized benchmarking and tomography will report incorrect answers without any syndrome \cite{Merkel2013}, and gateset tomography will report that the gateset failed to be Markovian, but will fail to diagnose in what way it was non-Markovian. Because BCSs change the error to a depolorizing channel, the correlations in the noise can be reduced, and the process can be made much closer to Markovian, and as we will show, this comes at no real cost to the fidelity of the implemented gate. Finally, unlike in \cite{Wallman2016, Campbell2017, Ware2018} we note that this method of coherent error mitigation is cheap to implement - it only requires a random choice of pulse definition at run time, in addition to the extra storage required to store the pulse shapes - no classical preprocessing or runtime frame tracking is required.

\section{GRAPE}\label{GRAPE}
Generating BCSs can be done in a variety of ways, using any quantum optimal control technique \cite{Caneva2011, Machnes2018} to find a family of controls. For simplicity in this paper we use the GRAPE algorithm to generate candidate pulseshapes to approximate the target gate. First described in \cite{Khaneja2005}, the GRAPE (GRadient Ascent Pulse Engineering) algorithm is a technique for finding piecewise constant control sequences that approximate a desired unitary, $U_T$. Defining our uncontrolled Hamiltonian as $H_0$, our control Hamiltonians as $H_{i\neq 0}$, and our \textit{control matrix} $u_{ij}$ as containing control amplitude associated with the $i^{th}$ time step and the $j^{th}$ hamiltonian, we can write our approximate unitary at any timestep as
\begin{equation}\label{eq:3}
  U_i = \exp\{-i\Delta t(H_0 + \sum_{j=1}^{n}u_{ij}H_{ij}\}
\end{equation}
Then, to measure the simularity of our approxiate unitary $U_n$, and our target unitary $U_T$, we can define a cost function $J(U) = Tr\{U_T^{\dagger}U_n\}$.

To optimize this cost function we can perform the following standard update loop for some threshold value $\varepsilon > 0$ and step size $\delta > 0$:
\begin{algorithm}[H]
\floatname{algorithm}
  \caption{\textsc{\textbf{Gradient Ascent}}}
  \begin{algorithmic}
    \While{$J(U_n) < (1-\varepsilon$)}
    \State $u_{ij} \rightarrow u_{ij} + \delta\frac{\partial J(U)}{\partial u_{ij}}$
    \For{$1 \leq i \leq n$}
    \State $U_i \rightarrow \exp\{-i\Delta t(H_0 + \sum_{i=0}^{n}u_{ij}H_i)\}$
    \EndFor
    \State $U \rightarrow \prod_1^nU_i$
    \EndWhile 
  \end{algorithmic}
\end{algorithm}

In general these gradients can be computed by propagating partial derivatives of the cost function with respect to control parameters through each timestep of the  via the chain rule. However, in \cite{Khaneja2005} Khaneja et al. derive a simple update formula that is correct to first order. In particular one can show that:
\begin{equation}\label{eq:update}
  \begin{split}
\frac{\partial J(U)}{\partial u_{ij}} = -2Re\{\braket{{U_{j+1}^{\dagger}...U_N^{\dagger} U_T}}{i\Delta tH_jU_j...U_1}\\
\braket{U_j...U_1}{U_{j+1}^{\dagger}...U_N^{\dagger} U_T}\} +  \mathcal{O}(\Delta t^2)
  \end{split}
\end{equation}


\section{Optimal Control Problem}\label{ocp}
\subsection{Random Gate Synthesis}
To explore the utility of BCSs, we consider the following Hamiltonian:
\begin{equation}\label{eq:2}
  H(t) = \delta_0H_0 + \sum_{i=1}^n (1 + \delta_i)c_i(t)H_i
\end{equation}
for control Hamiltonians $H_i$, free evolution Hamiltonian $H_0$ and random variables $\delta_i$, that model some small uncertainty in parameters in the Hamiltonian. Such a model might describe a superconducting qubit quantum processor where control amplitudes for the RF pulses vary over time, or a trapped ion quantum computer where the intensity, frequeny, and phase of the laser might drift over time. \needcite(Blueprint for a microwave trapped ion quantum computer) Correlations between different $\delta_i$ might arise if two of the controls have the same noise source. Examples of shared noise sources include $X$ and $Y$ gates in superconducting qubit architectures might use the same AWG and pulse envelope, and diurnal temperature drift of control electronics. \needcite

Given such a Hamiltonian, a threshold approximation fidelity $\mathcal{F}$, and a target gate $U_T$, we can use the technique described in \ref{GRAPE} to generate candidate pulse sequences that enact unitaries $U_i$ that approximate $U_T$, such that $Tr(U_T^{\dagger}U_i) \ge \mathcal{F}$. 

In this paper we have modified the update step in \ref{eq:update} to instead use approximately the following gradient:
\begin{align}\label{quadrature}
\int p(\vec{\delta})\frac{\partial J(U(\vec{\delta}))}{\partial u_{ij}} d\vec{\delta}
\end{align}
with $p(\vec{\delta})$ Gaussian distributed. This technique has been used in previous works such as \cite{Goerz2014} to ensure that the optimal control results are robust over a wide range of errors, and we approximate this integral in this paper by using Gaussian quadrature.\needcite Doing this ensures that the family of controls produced by our routine, $U_i$, perform moderately well over a range of control errors that might occur.

\subsection{Channel Approximation}
After using GRAPE or another optimal control routine to synthesize a collection of controls, we must find the weights $w_i$ such that the collection of controls form a BCS as described in (\ref{eq:1}). To do this, for each control $U_i$ we find the unitary error channel $\mathcal{E}_i$ such that $\mathcal{E}_iU_i=U_T$, where $U_T$ is the target gate. If we consider the Pauli-Liouville representation of this error channel, the diagonal terms are the \textit{stochastic} terms that arise from classical uncertainty, while the off-diagonal terms may more generally arise from \textit{coherent} operations. In particular, we see that we can write a convex sum over these channels as:
\begin{align}
 \frac{1}{N} \sum^N_{i=1} w_i \mathcal{E}^{\dagger} (U_T\rho U_T^{\dagger}) \mathcal{E}
\end{align}
Now, to approximate a depolarizing channel we define our optimal control problem to be the following, which minimizes the off-diagonal terms:
\begin{equation}\label{eq:minimization}
  \begin{split}
    &\underset{w_0, ..., w_N}{\textbf{minimize}} \{\sum_{i\neq j}^N|\sigma_i\Lambda(\sigma_j)|^2\}\\
    &\textbf{where}\ \Lambda(\sigma_j) := \sum^N_{i=1}w_i\mathcal{E}_i^{\dagger}\sigma_j\mathcal{E}_i\\
    &\textbf{subject to} \sum_{i=1}^Nw_i = 1
  \end{split}
\end{equation}

This can be solved with a constrained minimization algorithm, such as Sequential Least Squares Programming\cite{wright1999numerical}.

Previous authors have considered minimizing the diamond distance to the nearest Pauli or Clifford Channel \cite{Magesan2013}, and while this gives a good theoretical framework, it requires optimizing over the diamond norm, and in particular does not have the restriction that the optimal channel be decomposable into a given family of controls. Our routine, on the other hand, optimizes over an easy to compute sum. In the next section we give a simple example, followed by numerical results for one qubit and two qubits gates in sections \ref{1Q Gates} and \ref{2Q Gates}.

\begin{figure}
  \centering
  \includegraphics[width=.75\columnwidth]{simple_example.png}
  \caption{An example of a BCS. The red path is a $\pi$ pulse over-rotating clockwise, while the blue path is a $\pi$ pulse over-rotating counter-clockwise. The purple path is the average of the two.}
  \label{fig:simple_example}
\end{figure}

\section{A Simple Example}
As a somewhat trivial example, consider a single-qubit rotation-angle error, such as result from stochastic laser amplitude fluctuations. A BCS may consist of an $X_\pi$ pulse, as well as an $\bar X_\pi$ pulse (i.e., a clockwise and counter clockwise rotation of the qubit). In the case of excess amplitude, the $X_\pi$ pulse will result in an over-rotation error, while the $\bar X_\pi$ pulse results in an \emph{under}-rotation error. When it comes time to perform the target gate in a quantum circuit, one member of the BCS is chosen uniformly at random. This has the effect of decreasing the norm of the noise channel and decorrelating the over-rotation error (Figure \ref{fig:simple_example}). In this simple example, we can solve the minimization problem given by equation \ref{eq:minimization} analytically. In particular, if we choose the weights in \ref{eq:1} such that $\omega_i=1$, and we choose to represent our gates in the vectorized superoperator representation, then:

\begin{equation}
  \begin{gathered}
    \frac{1}{2}(X^*_{\pi + \epsilon}\otimes X_{\pi + \epsilon} + \bar X^*_{\pi + \epsilon}\otimes \bar X_{\pi + \epsilon}) \\  
    = (\sin^2{\frac{\pi + \epsilon}{2}}I\otimes I + \cos^2{\frac{\pi + \epsilon}{2}}X\otimes X)X\otimes X \\
    \approx ((1 - \epsilon^2)I\otimes I + \epsilon^2X\otimes X)X\otimes X
  \end{gathered}
\end{equation}
 
Therefore, for a rotational error of angle $\epsilon > 0$, we see that $X_\pi$ and  $\bar X_\pi$  form a BCS, with $\alpha\approx\epsilon^2$.


\section{Numerical Results}\label{numerical}
\subsection{1Q Gates}\label{1Q Gates}
 In this section, we present numerical results on generating one-qubit gates that together with $RZ(\theta$) rotations are universal for one-qubit computation. Our control Hamiltonian is given as: 
\begin{equation}\label{eq:1Qham}
  H = \epsilon\sigma_z + (1 + \delta)(c_x(t)\sigma_x + c_y(t)\sigma_y)
\end{equation}
where $\epsilon \sim \delta \sim \mathcal{N}(0, .001)$ We assume that the errors on $\sigma_x$ and $\sigma_y$ are perfecly correlated, as mentioned in Section \ref{ocp}. In our simulation we chose an total evolution time of $T=\pi$, and a number of steps $N=100$, with a threshold infidelity of $1E-3$.
\begin{figure*}
\centering
\includegraphics[width=\textwidth]{x2.png}
\caption{In the above we have used our method to produce a BCS for a $RX(\frac{\pi}{2})$ pulse, with the Hamiltonian given in \ref{eq:1Qham}. A) shows the sum of the squared norms of the off diagonal terms in the Pauli Transfer Matrix of $\mathcal{E}$. B) gives the corresponding infidelity for each member of the BCS, and the optimal choice of weights.}
\end{figure*}

\begin{figure*}
\centering
\includegraphics[width=\textwidth]{y2.png}
\caption{In the above we have used our method to produce a BCS for a $RY(\frac{\pi}{2})$ pulse, with the Hamiltonian given in \ref{eq:1Qham}. A) shows the sum of the squared norms of the off diagonal terms in the Pauli Transfer Matrix of $\mathcal{E}$. B) gives the corresponding infidelity for each member of the BCS, and the optimal choice of weights.}
\end{figure*}



\subsection{2Q Gates}\label{2Q Gates}
 In this section, we present numerical results on a generating one and two-qubit gates that together with $RZ(\theta)$ rotations are universal for two-qubit computation. Our control Hamiltonian is given as: 
\begin{equation} \label{eq:2Qham}
\begin{split}
H = &\sum_{j=1}^2(\epsilon_j\sigma_z^j + (1 + \delta_j)(c_x^jx(t)\sigma_x^j + c_y^j(t)\sigma_y^j)) \\
&+ \exp{(-i\frac{\sigma_z^1\otimes\sigma_z^2}{4})} 
\end{split}
\end{equation}
We again assume that the standard deviations are $.001$ on all parameters $\delta_j$ and $c^j_i$ and that errors on the single qubit $\sigma_x$ and $\sigma_y$ rotations are perfectly correlated. In this simulation we again had a threshold infidelity of $1E-3$, but we increased the total evolution time to $T=4\pi$, and increased the number of steps to $N=400$ so that the size of each time step was the same as in the one qubit example, however the total evolution time was greater to allow GRAPE more opportunities to find non-trivial pulseshapes. 
\begin{figure*}[t]
\centering
\includegraphics[width=\textwidth]{2Q.png}
\caption{In the above we have used our method to produce a BCS for a ZZ($\frac{\pi}{2}$) entangling gate with controls given by \ref{eq:2Qham}. A) shows the sum of the squared norms of the off diagonal terms in the Pauli Transfer Matrix of $\mathcal{E}$. B) gives the corresponding infidelity for each member of the BCS, and the optimal choice of weights.}
\end{figure*}


\section{Experimental Results}\label{experimental}
To demonstrate the realizability of this routine, we implemented it on a superconducting qubit, to calibrate an $RX(\frac{\pi}{2})$ pulse. The qubit being used had a 20.5 $\mu$s T1, and a 11.00 $\mu$s T2, and the pulse shapes being considered were 30ns long top hat pulse sequences, generated via a set-and-hold signal generator using the amplitudes shown in 

In this example we generated 10 candidate pulses using the GRAPE algorithm with a high convergence tolerance, with the intention that the optimizer would find solutions with some degree of noticeable coherent error. For each pulseshape, which enacts some unitary $U_i$, we performed an RPE-like experiment\cite{Kimmel2015} where the $\sigma_y$ and $\sigma_z$ expectations values were measured at the end of a sequence of $n$ applications of $U_i$, where n ranged from 1 to 100, and each circuit was sampled 1000 times. The results are plotted in [REF SUBPLOTS OF \ref{fig:rebit}]. Then, using the same optimization tool chain as in \ref{numerical}, we picked out the coeffients $p_i$ such that $p_i, U_i$ are a BCS, and performed the same experiment, but where for each shot of the experiment, we precompiled a different circuit. In particular, in our sampling procedure, circuit $U_{i_0}, U_{i_1}, ..., U_{i_{n-1}}$ occurs with probability $p_{i_0}p_{i_1}...p_{i_{n-1}}$. While in this example high fidelity, low coherent error controls can be produced [REFERENCE SUBPLOT OF \ref{fig:pulseshapes}], this demonstrates that this method can reduce coherent errors drastically.

\begin{figure}[H]
  \centering
  \includegraphics[width=.75\columnwidth]{example.png}
  \caption{An experimental implementation of our routine. We should include an array of images, maybe similar to this one, and then comment that in the image representing the BCS (above) that the noise is dominantly incoherent. The colors, ranging from purple to red, correspond to the depth into the sequence, where the darkest purple point is at the top of the rebit at $\ket{0}$. As the color becomes more red, the gate is applied more times, and consequently in the BCS example, moves the qubit's state vector closer to the maximally mixed state at the origin. The angle was computed by taking the arctangent of the $\sigma_y$ and $\sigma_z$ expectations, while the ther radius was computed by adding the two expectations in quadrature.}
  \label{fig:rebit}
\end{figure}

\section{Conclusion}
We have shown numerically and experimentally that drawing from a collection of implementations of a gate with the correct probabilties can reduce coherent error by an order of magnitude, while increasing incoherent error by a smaller amount, at virtually no cost to gate fidelity. We have demonstrated that these approximate controls can be generated through optimal control, and that the minimization problem is tractable. In addition, we have shown that it is possible to perform the routine on existing quantum hardware. Future directions for this work include moving the random gate selection from a precompilation step onto runtime FPGA logic, investigating other optimzation routines such as CRAB \cite{Caneva2011} and GOAT\cite{Machnes2018}, and using more precise benchmarking routines such as GST\cite{BlumeKohout2017} to more quantitatively investigate the performance of these routines. The code used in this paper is available at \cite{decorrelating_errors}.

\section{Acknowledgements}
%It might be interesting to show a dhistogram of the pribabilities assigned to each control to show that they aren't all zero. and maybe 



%$$ \epsilon, \delta \midtilde \sim \mathcal{N}(0, .001) $$
%$$\epsilon_0, \epsilon_1, \delta_0, \delta_1 \midtilde \sim \mathcal{N}(0, .001)$$
\bibliography{decorrelation.bib}
\end{document}
